(* README
 * Author: Alex Crichton <acrichto@andrew.cmu.edu>
 * Author: Robbie McElrath <rmcelrat@andrew.cmu.edu>
 *)

-----------------------------------------------------------------------
Lab 1
-----------------------------------------------------------------------

For lab 1 we implemented register allocation for L1 and a variety of other
improvements to make sure the compiler met the spec. The components of our
register allocation were: codegen, liveness analysis, allocation of registers
via graph coloring, and then formatting of instructions.

Codegen
========

Instruction selection isn't highly optimized yet. For now, we use the starter
code with the slight modification that if the operands for a binary operation
are immediates or registers, there's no need to move them to another temp
register. The only exception is a div and mod operation, which cannot take an
immediate for an argument, so a temp register is allocated for the immediate.

Liveness
========

Liveness analysis was performed over an abstract representation of each
instruction. Each instruction is mapped to a `rule` which is a 3-tuple of
use(l, x), def(l, x), and succ(l, l'). These rules, discussed in class, can be
generated for all instructions and then used in a generic way to perform
liveness analysis.

The analysis itself is straightforward and directly implemented from lecture.
Our choice of data structure was a list of sets. Each set in the list
corresponds to an instruction, and each set represents the live variables on
that line. We used the BinarySetFn functor to create a TempSet structure which
stores Temps.

Liveness analysis is performed from the last instruction to the first, and it
returns whether any of the TempSets were modified. If any were, then another
round of liveness analysis is performed. Otherwise, the TempSet list is passed
on to the register allocator/colorer.

Coloring
========
The list of sets from liveness analysis is converted into an interference graph
represented as a hashtable from nodes to an ('a, node_set) tuple. The set of
nodes represents neighboring nodes, and the 'a is the data associated with the
node (in our case {color:int, weight:int}). While constructing the graph, we
examine the instructions and see if it's a div or mod, and if so we add temps
into the graph and precolor them with eax and edx to ensure those registers are
free when the idiv is executed.

After the graph is constructed we update the weights of the nodes to account
for precoloring, then generate the SEO based on the algorithm from class. We
then use greedy coloring to assign colors and then allocate these colors to
physical registers based on a fixed mapping. Colors above 14 get mapped to
stack locations. The formatter makes sure these operations on stack locations
get converted into valid instructions.

Formatting
==========

Formatting the instructions turned out to be a non-trivial task to perform. Our
abstract assembly represents all binary operations as one operand is the result
of combining the other two. x86 assembly, however, does not always have
instructions which take three operands. In most cases, we were able to move
one of the sources into the destination and then perform the operation on the
destination and second source, but this does not always work. When the second
operand and the destination are the same, you overwrite values.

We had to special case for this reason about these scenarios, and the only odd
result we came up with is that if you are calculating `eax = ebx - eax`, then
the actual assembly results in:

  sub %ebx, %eax # performs %eax = %eax - %ebx
  neg %eax       # %eax = -%eax = %ebx - %eax

Beyond this, however, the cases of addition and multiplication didn't need
consideration because they are commutative.

Division and modular operations were a bit odd to deal with, but the relevant
registers (%eax, %edx) are ensured to not have live variables during a div
and mod operation, so we just move everything into the right place, perform
the operation, and move things out.

Instructions with multiple memory operands were also a difficult case, but we
were able to reduce it to only two scenarios.

  1. Moving between two memory locations - just move value through %r15d which
     was never allocated for this very reason.
  2. The result of a binary operation is in a memory location. If we assume
     that the destination of a binary operation is always in a register, then
     there's less consideration for multiple memory locations, so the result
     is calculated into %r15d in this case and then moved away.
