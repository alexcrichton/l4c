#[link(name = "l4c")];
#[deny(implicit_copies)];
#[deny(non_implicitly_copyable_typarams)];

extern mod std;

use core::util::*;
use utils::*;

mod utils {
  pub mod set;
  pub mod graph;
  pub mod bitv;
  pub mod profile;

  pub trait PrettyPrint {
    pure fn pp() -> ~str;
  }
  pub trait Graphable {
    fn dot(io::Writer);
  }
}

mod front {
  pub mod ast;
  mod error;
  mod mark;
  mod parse;
  mod pp;
  mod symbol;

  mod analysis {
    mod initcheck;
    mod maincheck;
    mod returncheck;
    mod typecheck;
  }
}

mod middle {
  pub mod ir;
  pub mod label;
  pub mod temp;
  pub mod ssa;
  pub mod liveness;
  mod trans;
}

mod back {
  mod alloc;
  mod arch;
  mod assem;
  mod codegen;
  mod ressa;
  mod spill;
  mod precolor;
}

fn help() {
  io::print(fmt!("Usage: %s", os::args()[0]));
  io::println(" [OPTION...] SOURCEFILE
where OPTION is
  -v        --verbose       verbose messages
            --dump-ast      pretty print the AST
            --dump-asm      pretty print the assembly before register allocaction
  -p        --profile       profile the compiler
  -l l4.h0  --header=l4.h0  header file for the program
            --dot           output DOT file for the cfg
            --safe          safe compilation with memory checks
            --unsafe        unsafe compilation with no memory checks
  -O 0      --optimize=0    level of optimizations to perform
  -m x64    --arch=x64      architecture to emit ([x64] | x86)

");
  libc::exit(0);
}

#[allow(non_implicitly_copyable_typarams)]
fn main() {
  use front::*;
  use front::analysis::*;
  use middle::*;
  use back::*;
  use std::getopts::*;

  let flags = ~[
    optflag("v"), optflag("verbose"),
    optflag("dump-ast"),
    optflag("profile"),
    optflag("f"), optflag("profile"),
    optopt("header"), optopt("l"),
    optflag("dot-ir"), optflag("dot-ssa"),
    optflag("dot-assem"), optflag("dot-spilled"), optflag("dot-ressa"),
    optflag("dot-colored"), optflag("dot-precolor"),
    optflag("safe"), optflag("unsafe"),
    optopt("O"), optopt("optimize"),
    optopt("m"), optopt("arch"),
    optflag("j"), optflag("json"),
  ];
  let m = &match getopts(vec::tail(os::args()), flags) {
    result::Ok(m)  => m,
    result::Err(e) => fail(fail_str(e))
  };
  if m.free.len() == 0 {
    help();
  }

  let out = do prof(m, "gen json") { get_json(m) };
  let ast = do prof(m, "parsing") { parse::from_str(copy out, copy m.free[0]) };
  do prof(m, "elaborating") { ast.elaborate(); }
  if opt_present(m, "dump-ast") {
    io::println(ast.pp());
  }
  do prof(m, "typecheck")   { analysis::typecheck::check(&ast)   }
  do prof(m, "returncheck") { analysis::returncheck::check(&ast) }
  do prof(m, "maincheck")   { analysis::maincheck::check(&ast)   }
  do prof(m, "initcheck")   { analysis::initcheck::check(&ast)   }

  let safe = opt_present(m, "safe") && !opt_present(m, "unsafe");
  let ir = do prof(m, "trans") { trans::translate(&ast, safe) };
  if opt_present(m, "dot-ir")  { ir.dot(io::stdout()); }
  pass(ir::ssa, &ir, m, "dot-ssa");

  let assem = do prof(m, "codegen") { codegen::codegen(&ir) };
  if opt_present(m, "dot-assem") { assem.dot(io::stdout()); }
  pass(precolor::constrain, &assem, m, "dot-precolor");
  pass(spill::spill,        &assem, m, "dot-spilled");
  pass(ressa::convert,      &assem, m, "dot-ressa");
  pass(alloc::color,        &assem, m, "dot-colored");

  let output = Path(m.free[0]).with_filetype("s");
  match io::file_writer(&output, ~[io::Truncate, io::Create]) {
    result::Ok(f)  => assem.output(f),
    result::Err(e) => fail(e)
  }
}

fn pass<T : Graphable, U>(f : &fn(&T) -> U, p : &T,
                          m : &std::getopts::Matches, s : &str) -> U {
  let ret = do prof(m, s) { f(p) };
  if std::getopts::opt_present(m, s) {
    p.dot(io::stdout());
  }
  return ret;
}

fn prof<U>(m : &std::getopts::Matches, s : &str, f : &fn() -> U) -> U {
  if std::getopts::opt_present(m, "profile") {
    profile::run(f, s)
  } else {
    f()
  }
}

#[allow(non_implicitly_copyable_typarams)]
fn get_json(m : &std::getopts::Matches) -> ~str {
  use std::getopts::*;

  if opt_present(m, "json") || opt_present(m, "j") {
    match io::read_whole_file_str(&path::Path(m.free[0])) {
      result::Ok(s) => s,
      result::Err(s) => fail(s)
    }
  } else {
    let header = option::or(opt_maybe_str(m, "l"), opt_maybe_str(m, "header"));
    let files = &match header {
      None => m.free,
      Some(file) => vec::append(~[file], m.free)
    };
    let {status, out, _} = run::program_output("parse/parser", *files);
    if status != 0 {
      io::print(out);
      libc::exit(1);
    }
    out
  }
}
