//! Coalescing of a colored graph to reduce the amount of moves needed when
//! removing phi functions.
//!
//! This file implements the algorithm described in Sebastian Hack's thesis
//! paper "Register Allocation for Program in SSA Form". One of the main results
//! of the coalescing problem in his paper is that it is NP-complete, so this
//! obviously doesn't impement an ideal solution. He outlines a rough heuristic,
//! however, which performs well a good portion of the time.
//!
//! The basic idea of the algorithm is to take "chunks" of related temps and
//! attempt to recolor them all to the same register. When doing so, some may
//! not be recolorable, so you slowly permanently fix temps in the graph to
//! certain colors while attempting to recolor others at the same time.
//!
//! This process contains quite a bit of computation, and has been attempted to
//! be heavily optimized as a result. Specific information about the algorithm
//! can be found in the comments of the functions. Some important terms used in
//! this implementation:
//!
//! # Affinity
//!
//! Foremost there is the notion of two temps being 'affine' to one another. If
//! temps x and y are affine, then if x and y are coalesced to the same color,
//! some exchange or move will be saved. All affinities are generated by phi
//! functions and PCopy instructions.
//!
//! Each affinity is also associated with a weight. This corresponds to how much
//! 'cost' is saved if the two temps are coalesced to the same color. This
//! implementation considers affinities inside loops to be more costly than
//! those outside of loops.
//!
//! Affinity is considered to be a transitive relation among temps, so temps can
//! be affine even if they're not directly associated with an affinity edge.
//!
//! # Chunk
//!
//! A chunk is just a set of nodes under consideration for coalescing. Each
//! chunk has an associated weight with it, which is just the sum of all the
//! affinity costs of the temps in the chunk. There is a queue of chunks to work
//! on which is a priority queue based on these weights.
//!
//! When coalescing a chunk, the entire chunk may not be recolored, so some of
//! the chunk may go back into the priority queue for re-evaluation later.

use std::cmp::{self, Ordering};
use std::collections::{HashMap, HashSet, BinaryHeap};
use std::isize;
use std::rc::Rc;
use std::u32;

use vec_map::VecMap;

use back::alloc;
use back::arch;
use back::assem::{CFG, Inst, Function};
use middle::ir::Edge;
use middle::liveness;
use middle::ssa;
use utils::graph::{NodeSet, NodeId};
use utils::profile;
use utils::{Temp, TempSet, TempBitVec, TempVecMap, FnvState};

type Location = (NodeId, isize);
type Affinities = HashMap<Temp, HashMap<Temp, usize, FnvState>, FnvState>;
type UseMap = HashMap<Temp, HashSet<Location, FnvState>, FnvState>;
type DefMap = HashMap<Temp, Location, FnvState>;

/// Representation of an affinity edge in graph.
///
/// An affinity edge involves two temporaries which are involved in a copy
/// instruction (e.g. pcopy or phi). The `usize` here is an arbitrary weight
/// associated with this affinity edge.
struct Affinity(Temp, Temp, usize);

/// Representation of a "chunk" of temps in a graph.
///
/// A chunk is a set of temps, none of which interfere with one another. The
/// `usize` here is the cost associated with this chunk, which is the sum of all
/// affinity edges in this chunk. In other words, each pair of temps in this
/// chunk has an associated affinity cost (see above), and the usize here is the
/// sum of them all.
struct Chunk(TempSet, usize);

struct Coalescer<'a, I: 'a> {
    // set of temps that are precolored
    precolored: TempBitVec,
    // For all temps with constraints, contains mapping of the constraints. This
    // is used when determining the admissible registers for a temp
    constraints: &'a alloc::ConstraintMap,
    // Actual coloring information that's modified
    colors: &'a mut alloc::ColorMap,

    // Set of fixed temps (cannot be changed)
    fixed: TempBitVec,
    // Map of affine temps, and their weights. The map works both ways, as in
    // looking up x then y is the same as looking up y then x
    affinities: Affinities,
    // Temporary mapping remembering the old colors of temps for rollbacks
    old_color: TempVecMap<u32>,

    // Mapping of a temp to where it's defined
    defs: &'a DefMap,
    // Mapping of a temp to the set of locations in which it is used
    uses: &'a UseMap,

    // find_interferences is an incredibly slow method, and this is a
    // precomputation of the input to a more efficient format to be used in that
    // method (more information on the method itself)
    liveness_map: &'a HashMap<NodeId, Vec<TempBitVec>, FnvState>,

    // This algorithm requires a lot of information about the interference graph
    // and associated components, and because interference information is very
    // costly to generate, there are a number of caches which store the results
    // of this computation to facilitate usage later on
    interference: HashMap<Temp, Rc<TempSet>, FnvState>,
    dominates: VecMap<VecMap<bool>>,

    f: &'a Function,
    live: &'a liveness::Analysis,
    info: &'a I,
    consider_pcopy: bool,
    max_temp: usize,
    max_color: u32,
}

pub fn optimize<I: ssa::Statement<Inst>>(
    f: &Function,
    live: &liveness::Analysis,
    colors: &mut alloc::ColorMap,
    precolored: &TempSet,
    constraints: &alloc::ConstraintMap,
    info: &I,
    pcopy: bool,
    max_color: u32)
{
    // Build up some static maps which are cheap and don't change
    let max_temp = colors.len();
    let lm = liveness_map(&f.cfg, info, live, max_temp);
    let (uses, defs) = use_def_maps(&f.cfg, info);

    let mut pre = TempBitVec::with_capacity(max_temp);
    for &t in precolored.iter() {
        pre.insert(t);
    }
    let mut c = Coalescer {
        fixed: TempBitVec::with_capacity(max_temp),
        affinities: HashMap::default(),
        colors: colors,
        old_color: TempVecMap::new(),
        precolored: pre,
        constraints: constraints,
        liveness_map: &lm,
        interference: HashMap::default(),
        dominates: VecMap::new(),
        defs: &defs,
        uses: &uses,
        f: f,
        live: live,
        info: info,
        consider_pcopy: pcopy,
        max_temp: max_temp,
        max_color: max_color,
    };
    c.coalesce();
}

/// Convert the liveness analysis to a mapping of bit vectors of the live temps
/// at each instruction in the program.
fn liveness_map<I>(cfg: &CFG, info: &I, live: &liveness::Analysis, max: usize)
                   -> HashMap<NodeId, Vec<TempBitVec>, FnvState>
    where I: ssa::Statement<Inst>
{
    let mut ret = HashMap::default();
    for (id, stms) in cfg.nodes() {
        let mut vec = Vec::new();
        let mut set = HashSet::default();
        set.extend(&live.in_[&id]);

        for (i, stm) in stms.iter().enumerate() {
            // we care about 'live-out' variables on an instruction
            liveness::apply(&mut set, &live.deltas[&id][i]);
            let mut bitv = TempBitVec::with_capacity(max);
            bitv.extend(&set);

            // at one instruction, the defined registers interfere with all live
            // out registers, even if the defined register isn't actually used
            // anywhere
            info.each_def(stm, &mut |t| bitv.insert(t));

            vec.push(bitv);
        }

        ret.insert(id, vec);
    }
    return ret;
}

/// Build up the internal maps about use/def information. This precomputes the
/// information about where each temp is defined and the set of uses for each
/// temp.
fn use_def_maps<I: ssa::Statement<Inst>>(
    cfg: &CFG, info: &I) -> (UseMap, DefMap)
{
    let mut uses = HashMap::default();
    let mut defs = HashMap::default();

    profile::dbg("building use/def", || {
        for (id, ins) in cfg.nodes() {
            build_use_def(id, info, ins, &mut uses, &mut defs);
        }
    });

    return (uses, defs);

    fn build_use_def<I>(n: NodeId, info: &I, ins: &Vec<Inst>,
                        uses: &mut UseMap, defs: &mut DefMap)
        where I: ssa::Statement<Inst>
    {
        for (i, ins) in ins.iter().enumerate() {
            info.each_def(ins, &mut |tmp| {
                assert!(defs.insert(tmp, (n, i as isize)).is_none());
            });
            info.each_use(ins, &mut |tmp| {
                add_use(tmp, (n, i as isize), uses);
            });
            if let Some((_, m)) = info.phi(ins) {
                for (&pred, &tmp) in m.iter() {
                    add_use(tmp, (pred, isize::MAX), uses);
                }
            }
        }
    }

    fn add_use(tmp: Temp, loc: Location, uses: &mut UseMap) {
        uses.entry(tmp).or_insert_with(|| HashSet::default())
            .insert(loc);
    }

}

impl<'a, I: ssa::Statement<Inst>> Coalescer<'a, I> {
    /// Perform the actual coalescing of the graph.
    fn coalesce(&mut self) {
        /* Algorithm 4.3 */
        let mut pq = self.build_chunks();
        while let Some(chunk) = pq.pop() {
            self.recolor_chunk(chunk, &mut pq);
        }
    }

    /// Actually attempts to recolor a chunk of temps to the same color
    ///
    /// Basically just iterates over each register and attemps to set the color
    /// of each temp in the set to this color. Afterwards the best affine subset
    /// (weighed by the cost of the set) is kept track of. Eventually this best
    /// subset's register is assigned to those temps and whatever temps
    /// remaining in the chunk are re-added to the priority queue
    fn recolor_chunk(&mut self, Chunk(tmps, cost): Chunk,
                     pq: &mut BinaryHeap<Chunk>) {
        let mut tmps = tmps;
        debug!("-------------------------------------------------------------");
        info!("coloring chunk {:?} {}", tmps, cost);
        let mut best_cost = 0;
        let mut best_color = u32::MAX;
        let mut best_set = HashSet::default();
        macro_rules! docolor {
            ($set:expr, $color:expr) => ({
                // Unfix all temps
                for &tmp in tmps.iter() {
                    self.fixed.remove(tmp);
                }
                for &tmp in $set.iter() {
                    self.recolor(tmp, $color);
                    self.fixed.insert(tmp);
                }
            })
        }

        // Sanity check that we're not coalescing fixed temps
        for &t in tmps.iter() {
            assert!(!self.fixed.contains(t));
        }

        // For each register, attempt to color everything to that register
        for r in 1..self.max_color + 1 {
            debug!("trying {}", r);
            docolor!(tmps, r);
            if let Some((m, mcost)) = self.best_subset(&tmps, r) {
                if mcost > best_cost {
                    best_color = r;
                    best_cost = mcost;
                    best_set = m;
                }
            }
        }
        if best_color == u32::MAX {
            info!("utterly impossible {:?}", best_set);
            return;
        }

        // If we found a good set, then fix everything to that color and perhaps
        // push the remaining temps in the chunk back into the priority queue
        debug!("-------------------------------------------------------------");
        info!("selected {} for {:?}", best_color, best_set);
        docolor!(best_set, best_color);
        for t in best_set.iter() {
            tmps.remove(t);
        }
        if tmps.len() > 0 {
            pq.push(Chunk(tmps, cost - best_cost));
        }
        debug!("-------------------------------------------------------------");
    }

    /// Calculates the best affine subset of 's'
    ///
    /// The set 's' can be divided into a number of disjoint subsets, each of
    /// which is internally pairwise affinity-related. Among these sets, one of
    /// them also has a maximum weight of temps within, and this function
    /// calculates and returns that set along with the weight of the set.
    fn best_subset(&mut self, s: &TempSet, c: u32) -> Option<(TempSet, usize)> {
        fn first(s: &TempSet) -> Temp {
            for &t in s.iter() { return t }
            panic!()
        }

        let mut maxweight = 0;
        let mut maxset = None;

        // Left is a set of temps that haven't yet been processed, and it's
        // initially the subset of 's' of all temps with color 'c'
        let mut left = HashSet::default();
        for &tmp in s.iter() {
            if self.colors[tmp] == c {
                left.insert(tmp);
            }
        }
        debug!("best of {:?} in {:?} for {}", left, s, c);

        // Iterate over the set of temps and partition as we go
        while left.len() > 0 {
            let mut subset = HashSet::default();
            let mut qweight = 1;

            // Start with the first temp in 'left', and then iteratively build
            // up everything that it's affine to. All of it's affinities get
            // added to this queue to be later processed and have all their
            // affinities added as well
            let mut queue = vec![first(&left)];
            while let Some(tmp) = queue.pop() {
                subset.insert(tmp);
                left.remove(&tmp);
                assert!(self.affinities.contains_key(&tmp));
                for (&next, &weight) in self.affinities[&tmp].iter() {
                    debug!("{} affine with {} cost {}", tmp, next, weight);
                    if left.contains(&next) && !subset.contains(&next) {
                        debug!("adding {}", next);
                        queue.push(next);
                        qweight += weight;
                    }
                }
            }

            debug!("found {:?} {}", subset, qweight);
            if qweight > maxweight {
                maxweight = qweight;
                maxset = Some(subset);
            }
        }
        if maxweight == 0 {
            debug!("no good subset");
            return None;
        }
        let maxset = maxset.unwrap();
        debug!("found {:?} {}", maxset, maxweight);
        return Some((maxset, maxweight));
    }

    /// This set of methods is used to actually recolor a temp to a particular
    /// color. It works by fixing a temp at a color, and then attempting to recolor
    /// all interfering neighbors of that temp recursively.
    ///
    /// If this ever panic!s, then the recoloration is rolled back and there's no
    /// effect. Before and after an invocation of recolor() the color mapping will
    /// be a valid mapping for all temps

    // Algorithm 4.4
    fn recolor(&mut self, t: Temp, c: u32) {
        // If the color isn't admissible or 't' is fixed, then nothing we can do
        if !self.admissible(t, c) { debug!("not admissible {} {}", t, c); return }
        if self.fixed.contains(t) { debug!("fixed {}", t); return }

        // Mark 't' as changed, and then attempt to recolor all our
        // interferences
        let mut changed = Vec::new();
        self.set_color(t, c, &mut changed);
        debug!("recoloring {} to {}", t, c);

        for &tmp in self.interferences(t).iter() {
            debug!("recoloring {} interfering with {}", tmp, t);
            if !self.avoid_color(tmp, c, &mut changed) {
                // rollback
                for &tmp in changed.iter() {
                    assert!(self.old_color.contains_key(&tmp));
                    self.colors.insert(tmp, self.old_color[tmp]);
                }
            }
        }
        for &tmp in changed.iter() {
            self.fixed.remove(tmp);
        }
    }

    fn set_color(&mut self, t: Temp, c: u32, changed: &mut Vec<Temp>) {
        debug!("setting {} to {}", t, c);
        self.fixed.insert(t);
        self.old_color.insert(t, self.colors[t]);
        changed.push(t);
        self.colors.insert(t, c);
    }

    fn avoid_color(&mut self, t: Temp, c: u32, changed: &mut Vec<Temp>) -> bool {
        let color = self.colors[t];
        // Certainly avoided if it's already not this color
        if color != c { debug!("avoided {} {}", t, c); return true }
        // Otherwise if it's fixed, then we're out of luck
        if self.fixed.contains(t) { debug!("fixed {}", t); return false }
        // If it the color isn't admissible, nothing we can do
        if self.precolored.contains(t) && c != color {
            debug!("{} fixed elsewhere ({} {})", t, c, self.colors[t]);
            return false
        }

        // After all that, we're in luck! Find a viable color for this temp
        // which is used least by the temp's interfering neighbors, fix the
        // color, and then recolor all our neighbors (again)
        let color = if self.precolored.contains(t) {
            c
        } else {
            self.min_color(t, c)
        };
        self.set_color(t, color, changed);
        for &tmp in self.interferences(t).iter() {
            if !self.avoid_color(tmp, color, changed) {
                debug!("failed to avoid on interference {}", tmp);
                return false;
            }
        }
        return true;
    }

    /// Calculates the minimum color used by t's interference neighbors
    ///
    /// The 'ignore' parameter is a register to blacklist and never use
    fn min_color(&mut self, t: Temp, ignore: u32) -> u32 {
        // cnts[i] = inft  =>  i can't be used for 't'
        let mut cnts = vec![u32::MAX; self.max_color as usize];
        for r in 1..self.max_color + 1 {
            if r != ignore && self.admissible(t, r) {
                cnts[r as usize - 1] = 0;
            }
        }

        // Iterate over our interferences and bump counts for their colors
        for &tmp in self.interferences(t).iter() {
            let idx = (self.colors[tmp] - 1) as usize;
            if cnts[idx] != u32::MAX {
                cnts[idx] += 1;
            }
        }

        // And finally find the minimum index
        let mut mini = 0;
        let mut min = u32::MAX;
        for (i, &cnt) in cnts.iter().enumerate() {
            if cnt < min {
                min = cnt;
                mini = i;
            }
        }
        mini as u32 + 1
    }

    /// Determines whether a color is admissible for a temp using the
    /// constraints placed on the temp from allocation/precoloring
    ///
    /// This doesn't look at neighbors to or anything like that, it's purely
    /// whether the temp 't' could ever have the color 'color'.
    fn admissible(&mut self, t: Temp, color: u32) -> bool {
        if self.precolored.contains(t) {
            return color == self.colors[t]
        }
        match self.constraints.get(&t) {
            None => true,
            Some(c) => c.allows(arch::num_reg(color)),
        }
    }

    /// Computes a priority queue of chunks to be processed for recoloring.
    ///
    /// A chunk is a set of temps which are all affine to one another, yet have
    /// no pairwise interferences among them. The optimal graph would be found
    /// if all chunks could be recolored to the same color (within each chunk).
    fn build_chunks(&mut self) -> BinaryHeap<Chunk> {
        // Algorithm 4.5
        let mut chunks = HashMap::new();
        let mut temp2chunk = HashMap::new();
        let mut next_chunk = 1;
        chunks.insert(0, Chunk(HashSet::default(), 0));

        // Process the highest cost affine temps first. For the affinity edge
        // (x, y) there are two chunks. We attempt to merge x's chunk with y's
        // chunk which can only be done if nothing pairwise interferes
        for Affinity(x, y, w) in self.find_affinities() {
            trace!("({}, {}) = {}", x, y, w);
            let xc = temp2chunk.get(&x).map(|x| *x).unwrap_or(0);
            let yc = temp2chunk.get(&y).map(|x| *x).unwrap_or(0);
            let mut merge;
            let weight;
            {
                // In a separate scope, see if we should skip merging the two
                // chunks of these two variables
                let Chunk(ref xs, xw) = chunks[&xc];
                let Chunk(ref ys, yw) = chunks[&yc];

                // Here try to find if anything pairwise interfers between the
                // chunks, and if it does we have to break out and just go to
                // the next affinity edge in the graph
                let cont = xs.iter().chain(Some(&x)).all(|&v| {
                    ys.iter().chain(Some(&y)).all(|&w| !self.interferes(v, w))
                });
                if !cont {
                    debug_assert!(xc != yc || xc == 0);
                    continue
                }

                // no element of the two chunks interfere, merge the chunks
                //
                // If x/y already belong to the same chunk we only count the
                // weight once, otherwise we add both chunk weights together.
                merge = HashSet::default();
                merge.insert(x);
                merge.insert(y);
                merge.extend(xs);
                merge.extend(ys);
                weight = w + if xc == yc {xw} else {xw + yw};
            }

            // In another scope where 'chunks' is mutable, insert/remove chunks
            let num = next_chunk;
            next_chunk += 1;
            for &tmp in merge.iter() {
                temp2chunk.insert(tmp, num);
            }
            chunks.insert(num, Chunk(merge, weight));

            // remove the old chunks so long as they're not the base ones
            if xc != 0 { chunks.remove(&xc); }
            if yc != 0 { chunks.remove(&yc); }
        }

        // Finally insert all chunks into a priority queue now that we've
        // finalized what each chunk is going to be.
        //
        // Here we also perform a sanity check to ensure that the weight we've
        // calculated matches with what we're expecting.
        chunks.into_iter().filter_map(|(i, c)| {
            if cfg!(debug_assertions) {
                let Chunk(ref set, weight) = c;
                let real_weight = set.iter().map(|t1| {
                    set.iter().map(|t2| {
                        assert!(!self.interferes(*t1, *t2));
                        self.affinities.get(t1).and_then(|m| m.get(t2))
                            .map(|x| *x).unwrap_or(0)
                    }).fold(0, |a, b| a + b)
                }).fold(0, |a, b| a + b);
                assert!(real_weight % 2 == 0);
                assert!(real_weight / 2 == weight, "{} != {} for {:?}",
                        real_weight / 2, weight, set);
            }
            if i == 0 {None} else {Some(c)}
        }).collect()
    }

    /// Creates a sorted vector of all affinity edges in the interference graph
    ///
    /// This simply traverses the entire CFG looking for phi nodes and PCopy
    /// nodes to generate affinity relations. The final vector is sorted with
    /// the most expensive weight first.
    fn find_affinities(&mut self) -> Vec<Affinity> {
        let mut to_visit = vec![(self.f.root, 1)];
        let mut visited = HashSet::new();

        // First up traverse the entire graph and record all affine edges we
        // see. We record in both directions to ensure they're all listed.
        while let Some((n, weight)) = to_visit.pop() {
            let first_time = visited.insert(n);
            debug_assert!(first_time);

            // We have a more costly weight if we're moving into a loop
            let weight = weight + if self.f.loops.contains_key(&n) {1} else {0};
            for ins in self.f.cfg.node(n).iter() {
                if let Some((def, map)) = self.info.phi(ins) {
                    for (_, &tmp) in map.iter() {
                        if tmp != def {
                            self.add_affine(tmp, def, weight);
                            self.add_affine(def, tmp, weight);
                        }
                    }
                }

                if self.consider_pcopy {
                    if let Inst::PCopy(ref copies) = *ins {
                        for &(a, b) in copies.iter() {
                            debug_assert!(a != b);
                            self.add_affine(a, b, weight);
                            self.add_affine(b, a, weight);
                        }
                    }
                }
            }

            for (succ, edge) in self.f.cfg.succ_edges(n) {
                if visited.contains(&succ) { continue }
                // If we're moving out of a loop, decrement the weight
                let weight = match *edge {
                    Edge::FLoopOut | Edge::LoopOut => weight - 1,
                    _ => weight
                };
                to_visit.push((succ, weight));
            }
        }

        // After we've found all affine edges (which means we've calculated the
        // final weight for all the edges) we then go through our analysis and
        // generate all affinity edges. Finally we sort the vector-to-return to
        // ensure the first affinity edge has the maximum weight.
        let mut ret = self.affinities.iter().flat_map(|(&a, map)| {
            map.iter().filter_map(move |(&b, &weight)| {
                if a < b {Some(Affinity(a, b, weight))} else {None}
            })
        }).collect::<Vec<_>>();
        ret.sort_by(|a, b| b.2.cmp(&a.2));
        return ret
    }

    fn add_affine(&mut self, a: Temp, b: Temp, weight: usize) {
        // We define the weight of the affine edge (a, b) as the maximum weight
        // that we find while traversing the CFG, so if we've previously seen it
        // then we just take the max of the two and put it back in the map.
        let slot = self.affinities
                       .entry(a).or_insert_with(|| HashMap::default())
                       .entry(b).or_insert(weight);
        *slot = cmp::max(*slot, weight);
    }

    //**************************************************************************
    // The following methods deal with finding information about the
    // interference graph without actually building the interference graph
    //**************************************************************************

    /// Tests whether two temps interfere within the interference graph
    ///
    /// This is done without actually creating the interference graph
    fn interferes(&mut self, x: Temp, y: Temp) -> bool {
        // Algorithm 4.6
        let xdef = self.defs[&x];
        let ydef = self.defs[&y];
        // Find (t, b) such that t's definition dominates b's
        let (t, b) = if self.dominates(ydef, xdef) {
            (y, x)
        } else if self.dominates(xdef, ydef) {
            (x, y)
        } else {
            // if neither dominate each other, no way they can interfere
            return false;
        };

        // If 't' is live out in b's definition, then they definitely interfere
        let (bdef, bline) = self.defs[&b];
        if self.live.out[&bdef].contains(&t) {
            return true;
        }

        // Otherwise, we need to check each use of 't', and if the use is
        // dominated by b's definition then there's an interference
        if let Some(m) = self.uses.get(&t) {
            for &loc in m.iter() {
                if self.dominates((bdef, bline), loc) {
                    return true;
                }
            }
        }

        // If all that passes, then these two variables do not interfere
        return false;
    }

    /// Iterates over all temps which 't' interferes with using the given
    /// closure
    ///
    /// This is the most costly operation in coalescing. Interference graphs are
    /// often very large and there's a reason that the graph itself isn't
    /// actually computed ahead of time.
    ///
    /// To see problems in optimization, see find_interferences
    fn interferences(&mut self, t: Temp) -> Rc<TempSet> {
        // definitely cache information once we've calculated it
        if let Some(s) = self.interference.get(&t) {
            return s.clone()
        }

        // Prelude to Algorithm 4.7 (find_interferences)
        let mut visited = HashSet::default();
        let mut bitv = TempBitVec::with_capacity(self.max_temp);
        match self.uses.get(&t) {
            Some(uses) => {
                for &(block, _) in uses.iter() {
                    self.find_interferences(t, block, &mut bitv, &mut visited);
                }
            }
            // Dead variables never used should only have their point of
            // definition processed because those variables live over the
            // instruction of definition should be considered as interfering
            None => {
                let (block, _) = self.defs[&t];
                self.find_interferences(t, block, &mut bitv, &mut visited);
            }
        }
        let mut set = HashSet::default();
        for x in bitv.iter() {
            if x != t {
                set.insert(x);
            }
        }
        debug!("{} interferencs: {:?}", t, set);
        let ret = Rc::new(set);
        self.interference.insert(t, ret.clone());
        return ret;
    }

    /// Actual grunt work of finding interferences of a variable in a graph
    ///
    /// I've attempted to heavily optimize this method as much as possible.
    /// Normal TempSet structures and things like that aren't used here because
    /// they're just too costly. These are the optimizations so far:
    ///
    ///    1. Use bit vectors instead of HashSet TempSet structures
    ///
    ///          This ended up being a huge win because the operations needed,
    ///          get/set/union are all far faster on a bit vector than on a hash
    ///          map or similar
    ///
    ///    2. Precompute live sets of variables at all instructions
    ///
    ///          The only goal of this algorithm is to iterate from a usage
    ///          point up to the definition, collecting all variables that are
    ///          simultaneously live with 'x'. All variables live at all
    ///          instructions have already been converted into bit vectors, so
    ///          the union operation is nice and cheap.
    ///
    /// Basially, if this code looks really weird and like it's not using any
    /// convention used in the rest of the compiler, it's because it's balls
    /// slow, but really useful. This also explains the precomputation done far
    /// above this function.
    fn find_interferences(&mut self, x: Temp, n: NodeId, set: &mut TempBitVec,
                          visited: &mut NodeSet) {
        // Algorithm 4.7
        if visited.contains(&n) { return }
        visited.insert(n);

        // the set of live variables has already been computed at all
        // instructions, so we just need to union whatever sets have our
        // variable in question
        for bitv in self.liveness_map[&n].iter() {
            if bitv.contains(x) {
                set.union(bitv);
            }
        }

        let def = self.defs[&x];
        for pred in self.f.cfg.preds(n) {
            // Be sure to check the dominance relation relative to the end of the
            // predecessor's block as opposed to the start as x could have been
            // defined in the block
            if self.dominates(def, (pred, isize::MAX)) {
                self.find_interferences(x, pred, set, visited);
            }
        }
    }

    /// Tests wehther a location dominates another location in the graph
    fn dominates(&mut self, (a, aline): Location, (b, bline):Location) -> bool {
        // Same block? well that's easy
        if a == b {
            return aline < bline;
        }
        if let Some(&s) = self.dominates.get(&a).and_then(|m| m.get(&b)) {
            return s
        }
        // Otherwise we just walk up b's idominator tree to see if we ever find
        // a, if we find the root first, then a doesn't dominate b
        let mut cur = b;
        let mut dominates = false;
        let idominator = &self.f.ssa.idominator;
        loop {
            let nxt = idominator[&cur];
            if nxt == cur {
                break
            } else if nxt == a {
                dominates = true;
                break
            }
            cur = nxt;
        }
        self.dominates.entry(a).or_insert_with(|| VecMap::new())
                      .insert(b, dominates);
        self.dominates.entry(b).or_insert_with(|| VecMap::new())
                      .insert(a, !dominates);
        return dominates;
    }
}

impl PartialEq for Chunk {
    fn eq(&self, other: &Chunk) -> bool {
        match (self, other) {
            (&Chunk(_, a), &Chunk(_, b)) => a == b
        }
    }
}
impl Ord for Chunk {
    fn cmp(&self, other: &Chunk) -> Ordering {
        match (self, other) {
            (&Chunk(_, a), &Chunk(_, b)) => a.cmp(&b)
        }
    }
}
impl PartialOrd for Chunk {
    fn partial_cmp(&self, other: &Chunk) -> Option<Ordering> {
        match (self, other) {
            (&Chunk(_, a), &Chunk(_, b)) => a.partial_cmp(&b)
        }
    }
}
impl Eq for Chunk {}
