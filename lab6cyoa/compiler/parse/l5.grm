(* L5 Compiler
 * L5 grammar
 * Author: Alex Crichton <acrichto@andrew.cmu.edu>
 * Author: Robbie McElrath <rmcelrat@andrew.cmu.edu>
 *)

structure A = Ast

(* for simplicity, we only mark expressions, not statements *)

(* mark e with region (left, right) in source file *)
fun marker (a, (l, r)) = Mark.mark' (a, ParseState.ext (l, r))
val mark = A.Marked o marker
val marks = A.Markeds o marker
val markg = A.Markedg o marker
val markc = A.Markedc o marker

fun convert_exp2 (exp1, left) (SOME binop, exp2, NONE, right) =
      mark (A.BinaryOp(binop, exp1, exp2), (left, right))
  | convert_exp2 (exp1, left) (NONE, exp2, SOME exp3, right) =
      mark (A.Ternary(exp1, exp2, exp3, ref A.NULL), (left, right))
  | convert_exp2 _ _ = raise Fail "Invalid input to convert_exp2!"

fun genpost (exp, oper) = A.Assign(exp, oper, A.Const(Word32.fromInt 1))
fun genptrinc (exp, oper) =
  A.Seq (A.Express (A.Deref (exp, ref A.NULL)), genpost (exp, oper))

%%
%header (functor L5LrValsFn (structure Token : TOKEN))

%term
   EOF
 | SEMI
 | INTCONST  of Word32.word
 | IDENT     of Symbol.symbol
 | TYPE      of Symbol.symbol
 | CLASSNAME of Symbol.symbol
 | TRUE | FALSE | NULL | ALLOC | ALLOCARR | NEW | SELF
 | INT | BOOL | STRUCT | CLASS | EXTENDS
 | PLUS | MINUS | STAR | SLASH | PERCENT
 | PLUSPLUS | MINUSMINUS
 | AND | PIPE | BANG | CARET | LSHIFT | RSHIFT | TILDE
 | ANDAND | PIPEPIPE | EQUALS | NEQUALS
 | ASSIGN | PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | PERCENTEQ
 | XOREQ | ANDEQ | OREQ | LSHIFTEQ | RSHIFTEQ
 | LESS | LESSEQ | GREATER | GREATEREQ
 | LBRACE | RBRACE
 | LPAREN | RPAREN
 | COMMA | PERIOD | ARROW | LBRACKET | RBRACKET
 | IF | ELSE | WHILE | FOR | CONTINUE | BREAK | RETURN | TYPEDEF
 | QUESTION | COLON | CONS
 | UNARY | ASNOP
(* UNARY and ASNOP are dummy terminals.
 * We need dummy terminals if we wish to assign a precedence
 * to a rule that does not correspond to the precedence of
 * the rightmost terminal in that rule.
 * Implicit in this is that precedence can only be inferred
 * terminals. Therefore, don't try to assign precedence to "rules"
 *)

%nonterm
   program  of A.program
 | gdecls   of A.gdecl list
 | gdecl    of A.gdecl
 | fdecl    of A.gdecl
 | fdef     of A.gdecl
 | typedef  of A.gdecl
 | sdecl    of A.gdecl
 | sdef     of A.gdecl
 | field    of (A.typ * A.ident)
 | field_list         of (A.typ * A.ident) list
 | param    of (A.typ * A.ident)
 | param_list_follow  of (A.typ * A.ident) list
 | param_list         of (A.typ * A.ident) list
 | arg_list_follow    of A.exp list
 | arg_list           of A.exp list
 | stmts    of A.stm
 | decl     of A.stm
 | stmt     of A.stm
 | simp     of A.stm
 | simpnodef of A.stm
 | simppostop of A.exp * A.binop option
 | control  of A.stm
 | block    of A.stm
 | exp      of A.exp
 | expnostar of A.exp
 | exp2     of A.binop option * A.exp * A.exp option * int
 | asnop    of A.binop option
 | unop     of A.unop
 | postop   of A.binop
 | step     of A.stm
 | simpopt  of A.stm
 | elseopt  of A.stm
 | typ      of A.typ
 | class    of A.gdecl
 | classdef of A.ident
 | cdecls   of A.cdecl list
 | cdecl    of A.cdecl
 | classfun of A.gdecl
 | extendsopt of A.ident option

%verbose       (* print summary of errors *)
%pos int       (* positions *)
%start program (* what is the top-most non-terminal expected to be ? *)
%eop EOF       (* which terminal ends parsing? *)
%noshift EOF   (* we should never shift an EOF *)
%nodefault     (* ? seems like a good idea ? *)
%pure          (* Apparently has the effect of executing the reduce code as soon
                  as a reduction is possible. *)

%name L5

(* The precedence grows down! *)
%right ASNOP
%right QUESTION COLON
%left PIPEPIPE
%left ANDAND
%left PIPE
%left CARET
%left AND
%left EQUALS NEQUALS
%left LESS LESSEQ GREATER GREATEREQ
%left LSHIFT RSHIFT
%left PLUS MINUS
%left STAR SLASH PERCENT
%right UNARY
%left LPAREN LBRACKET ARROW PERIOD

%%

(* note that MAIN is not intended to be a keyword.
 * the current rule is an expedient hack for forward compatability *)
program    : gdecls                     (gdecls)

gdecls     :                            ([])
           | gdecl gdecls               (gdecl::gdecls)

gdecl      : fdecl                      (markg (fdecl, (fdeclleft, fdeclright)))
           | fdef                       (markg (fdef, (fdefleft, fdefright)))
           | typedef SEMI               (markg (typedef,
                                                (typedefleft, typedefright)))
           | sdecl                      (markg (sdecl, (sdeclleft, sdeclright)))
           | sdef                       (markg (sdef, (sdefleft, sdefright)))
           | class SEMI                 (markg (class, (classleft, classright)))
           | classfun                   (markg (classfun,
                                                (classfunleft, classfunright)))

classdef   : CLASS IDENT                (Symbol.addclass IDENT; IDENT)

class      : classdef extendsopt LBRACE cdecls RBRACE
                                        (A.Class (classdef, cdecls, extendsopt))

extendsopt :                            (NONE)
           | EXTENDS CLASSNAME          (SOME CLASSNAME)

cdecls     :                            ([])
           | cdecl cdecls               (markc (cdecl,
                                               (cdeclleft, cdeclright))::cdecls)

cdecl      : typ IDENT SEMI             (A.CField (typ, IDENT))
           | typ IDENT param_list SEMI  (A.CFunDecl (typ, IDENT, param_list))
           | CLASSNAME param_list SEMI  (A.CFunDecl (A.PTR (A.CLASS CLASSNAME),
                                                     CLASSNAME, param_list))

classfun   : typ CLASSNAME CONS IDENT param_list block
                                        (A.CFun (CLASSNAME, typ, IDENT,
                                                 param_list, block))
           | CLASSNAME CONS CLASSNAME param_list block
                                        (A.CFun (CLASSNAME1,
                                                 A.PTR (A.CLASS CLASSNAME1),
                                                 CLASSNAME2, param_list, block))

fdecl      : typ IDENT param_list SEMI  (A.IntDecl (typ, IDENT, param_list))

fdef       : typ IDENT param_list block (A.Fun (typ, IDENT, param_list, block))

typedef    : TYPEDEF typ IDENT          (Symbol.addtype IDENT;
                                         A.Typedef (IDENT, typ))

param      : typ IDENT                  (typ, IDENT)

param_list_follow :                                 ([])
                  | COMMA param param_list_follow   (param::param_list_follow)

param_list : LPAREN RPAREN                          ([])
           | LPAREN param param_list_follow RPAREN  (param::param_list_follow)

sdecl      : STRUCT IDENT SEMI          (A.StrDecl IDENT)
           | STRUCT TYPE SEMI           (A.StrDecl TYPE)

sdef       : STRUCT IDENT LBRACE field_list RBRACE SEMI
                                        (A.Struct (IDENT, field_list))
           | STRUCT TYPE LBRACE field_list RBRACE SEMI
                                        (A.Struct (TYPE, field_list))

field      : typ IDENT SEMI             ((typ, IDENT))
           | typ TYPE SEMI              ((typ, TYPE))

field_list :                            ([])
           | field field_list           (field :: field_list)

block      : LBRACE stmts RBRACE        (stmts)

typ        : INT                        (A.INT)
           | BOOL                       (A.BOOL)
           | TYPE                       (A.TYPEDEF TYPE)
           | CLASSNAME                  (A.CLASS CLASSNAME)
           | typ STAR                   (A.PTR typ)
           | typ LBRACKET RBRACKET      (A.ARRAY typ)
           | STRUCT IDENT               (A.STRUCT IDENT)
           | STRUCT TYPE                (A.STRUCT TYPE)

decl       : typ IDENT                  (marks (A.Declare (IDENT, typ, A.Nop),
                                                (typleft, IDENTright)))
           | typ IDENT ASSIGN exp       (marks (A.Declare (IDENT, typ,
                                                  A.Assign(A.Var IDENT, NONE, exp)),
                                                (typleft, expright)))

stmts      :                                 (A.Nop)
           | stmt stmts                      (A.Seq (stmt, stmts))

stmt       : simp SEMI                  (marks (simp, (simpleft, simpright)))
           | control                    (marks (control, (controlleft,
                                                          controlright)))
           | block                      (marks (block, (blockleft, blockright)))

simp       : simpnodef    (simpnodef)
           | decl         (decl)

simpnodef  : exp asnop exp %prec ASNOP
                                         (A.Assign (exp1, asnop, exp2))
           | STAR simppostop %prec UNARY (genptrinc simppostop)
           | simppostop %prec UNARY      (genpost simppostop)
           | exp                         (A.Express exp)

simppostop : expnostar postop %prec UNARY    (expnostar, SOME postop)

simpopt    :                           (A.Nop)
           | simp                      (marks (simp, (simpleft, simpright)))

step       :                           (A.Nop)
           | simpnodef                 (marks (simpnodef,
                                               (simpnodefleft, simpnodefright)))

elseopt    :                           (A.Nop)
           | ELSE stmt                 (marks (stmt, (ELSEleft, stmtright)))

control    : IF LPAREN exp RPAREN stmt elseopt  (A.If(exp, stmt, elseopt))
           | WHILE LPAREN exp RPAREN stmt       (A.While (exp, stmt))
           | FOR LPAREN simpopt SEMI exp SEMI step RPAREN stmt
                                      (A.For (simpopt, exp, step, stmt))
           | CONTINUE SEMI   (marks (A.Continue, (CONTINUEleft, CONTINUEright)))
           | BREAK SEMI      (marks (A.Break, (BREAKleft, BREAKright)))
           | RETURN exp SEMI (marks (A.Return exp, (RETURNleft, expright)))

arg_list_follow :                               ([])
                | COMMA exp arg_list_follow     (exp::arg_list_follow)

arg_list   : LPAREN RPAREN                      ([])
           | LPAREN exp arg_list_follow RPAREN  (exp::arg_list_follow)

exp        : STAR exp                   (mark (A.Deref (exp, ref A.NULL),
                                              (STARleft, expright)))
           | expnostar                  (mark (expnostar, (expnostarleft,
                                                           expnostarright)))

expnostar  : IDENT                      (A.Var IDENT)
           | LPAREN exp RPAREN          (exp)
           | INTCONST                   (A.Const INTCONST)
           | TRUE                       (A.Bool true)
           | FALSE                      (A.Bool false)
           | NULL                       (A.Null)
           | SELF                      (A.Self)
           | unop exp %prec UNARY       (A.UnaryOp(unop, exp))
           | exp exp2                   (convert_exp2 (exp, expleft) exp2)
           | IDENT arg_list             (A.Call (IDENT, arg_list))
           | exp PERIOD IDENT           (A.Field (exp, IDENT, ref A.NULL))
           | exp ARROW IDENT            (A.Field (A.Deref (exp, ref A.NULL),
                                                  IDENT, ref A.NULL))
           | exp ARROW TYPE             (A.Field (A.Deref (exp, ref A.NULL),
                                                  TYPE, ref A.NULL))
           | ALLOC LPAREN typ RPAREN    (A.Alloc typ)
           | ALLOCARR LPAREN typ COMMA exp RPAREN (A.AllocArray (typ, exp))
           | exp LBRACKET exp RBRACKET (A.ArrSub (exp1, exp2, ref A.NULL))
           | NEW CLASSNAME arg_list    (A.Allocate (CLASSNAME, arg_list))
           | exp ARROW IDENT arg_list  (A.Invoke (A.Deref (exp, ref A.NULL),
                                                  IDENT, arg_list))
           | exp PERIOD IDENT arg_list (A.Invoke (exp, IDENT, arg_list))

exp2       : PLUS exp         (SOME(A.PLUS), exp, NONE, expright)
           | MINUS exp        (SOME(A.MINUS), exp, NONE, expright)
           | STAR exp         (SOME(A.TIMES), exp, NONE, expright)
           | SLASH exp        (SOME(A.DIVIDEDBY), exp, NONE, expright)
           | PERCENT exp      (SOME(A.MODULO), exp, NONE, expright)
           | LESS exp         (SOME(A.LESS), exp, NONE, expright)
           | LESSEQ exp       (SOME(A.LESSEQ), exp, NONE, expright)
           | GREATER exp      (SOME(A.GREATER), exp, NONE, expright)
           | GREATEREQ exp    (SOME(A.GREATEREQ), exp, NONE, expright)
           | EQUALS exp       (SOME(A.EQUALS), exp, NONE, expright)
           | NEQUALS exp      (SOME(A.NEQUALS), exp, NONE, expright)
           | ANDAND exp       (SOME(A.LAND), exp, NONE, expright)
           | PIPEPIPE exp     (SOME(A.LOR), exp, NONE, expright)
           | AND exp          (SOME(A.BAND), exp, NONE, expright)
           | CARET exp        (SOME(A.XOR), exp, NONE, expright)
           | PIPE exp         (SOME(A.BOR), exp, NONE, expright)
           | LSHIFT exp       (SOME(A.LSHIFT), exp, NONE, expright)
           | RSHIFT exp       (SOME(A.RSHIFT), exp, NONE, expright)
           | QUESTION exp COLON exp     (NONE, exp1, SOME exp2, exp2right)

asnop      : ASSIGN                     (NONE)
           | PLUSEQ                     (SOME(A.PLUS))
           | MINUSEQ                    (SOME(A.MINUS))
           | STAREQ                     (SOME(A.TIMES))
           | SLASHEQ                    (SOME(A.DIVIDEDBY))
           | PERCENTEQ                  (SOME(A.MODULO))
           | ANDEQ                      (SOME(A.BAND))
           | XOREQ                      (SOME(A.XOR))
           | OREQ                       (SOME(A.BOR))
           | LSHIFTEQ                   (SOME(A.LSHIFT))
           | RSHIFTEQ                   (SOME(A.RSHIFT))

unop       : BANG                       (A.BANG)
           | TILDE                      (A.INVERT)
           | MINUS                      (A.NEGATIVE)

postop     : PLUSPLUS                   (A.PLUS)
           | MINUSMINUS                 (A.MINUS)
