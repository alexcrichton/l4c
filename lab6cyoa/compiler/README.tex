\documentclass{article}
% \usepackage{graphs}
\usepackage{fullpage}
\usepackage{array}
\usepackage{setspace}
\newcommand{\wild}{\mbox{\tt\char"5F}}

\newcommand{\nonterm}[1]{$\langle${#1}$\rangle$}
\newcommand{\tok}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\term}[1]{\textbf {#1}}
\newcommand{\OR}{\ensuremath{\ | \ \ }}

\newcommand{\proves}{\vdash}

\newcommand{\G}{\Gamma}
\newcommand{\cons}[2]{#1, \, #2}
\newcommand{\typed}[2]{#1 : #2}
\newcommand{\valid}[1]{#1 \; \mathit{valid}}
\newcommand{\typof}[3]{{#1} \proves \typed{#2}{#3}}


\title{Assignment 6\\ Object-oriented C0}
\author{15-411: Compiler Design\\
Alex Crichton (acrichto) and Robbie McElrath (rmcelrat)}

\begin{document}
\maketitle
\renewcommand{\baselinestretch}{1.0}

\section{Introduction}

We decided to add object-oriented features to to C0 for our lab 6. We strove to
maintain compatibility as much as possible with \emph{L4}, while supporting the
major features of OO programming that one would expect when working with a
language like C++ or Java.

Our compiler supports the basics of object oriented programming: classes,
single-class inheritance, method overriding, constructors, protected/private
access to fields/methods, and \texttt{super} invocation of parent methods.

\section{Specification}
The following are the changes/additions to the \emph{L5} specification. Any part
of the specification not addressed here is unchanged.

\subsection{Grammar}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{lcl}
  \nonterm{gdecl}      & ::= & $\cdots$ \OR \nonterm{cdecl} \OR \nonterm{mdef} \\
  \nonterm{cdecl}      & ::= & \term{class} \term{ident} \nonterm{ext-opt} \term{\{} \nonterm{citem-list} \term{\}} \term{;} \\
  \nonterm{ext-opt}    & ::= & $\epsilon$ \OR \term{extends} \term{ident} \\
  \nonterm{citem-list} & ::= & $\epsilon$ \OR \nonterm{citem} \nonterm{citem-list} \\
  \nonterm{citem}      & ::= & \nonterm{field} \OR \nonterm{fdecl} \OR \term{public:} \OR \term{private:} \\
  \nonterm{mdef}       & ::= & \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
                       & \OR & \nonterm{type} \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
  \nonterm{exp}        & ::= & $\cdots$ \OR \term{new} \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{super}  \nonterm{arg-list} \OR \term{super} \verb"->" \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{this} \verb"->" \term{ident} \OR \term{this} \verb"->" \term{ident} \nonterm{arg-list} \\
\end{tabular}

\subsection{Static Semantics}
\subsubsection{Classes}
\begin{itemize}
\item Classes follow the same lexical scoping rules as other gdecls (they are
      only available after their declaration).
\item Class declarations and definitions \emph{cannot} appear in external files.
\item Classes can be declared multiple times as long as the declarations are
      consistent, but their methods can be defined only once. Declared methods
      are not required to be defined.
\item Class names are types, and their names are in the type namespace.
\item Methods within classes form their own namespace, and can only be accessed
      via the object they belong to.
\item Functions that are not methods of a given class can only access the public
      fields and functions of that class.
\item Methods can access all fields and methods (both public and private) of any
      object that are the same type or a subtype of the class the method belongs to.
\item Subclasses do not get access to their parent's private fields or methods.
\item Fields within classes are in the same namespace as local variables within
      methods of that class (they can be referenced directly by name, but only
      by methods of the class they belong to).
\item Local variables are allowed to shadow class fields.
\item \term{super} may only be used within methods of a class $\alpha$ that
      extends some class $\beta$. \term{super} resolves to $\beta$ in this
      case. Subclasses can only access their direct parent via \term{super}.
\item Non-constructors cannot call their own constructor or their parent's.
      Constructors are the only method allowed to call the parent constructor.
\end{itemize}

\subsubsection{Typechecking}
\begin{itemize}
\item 
\end{itemize}

\subsection{Dynamic Semantics}


\section{Implementation}

\section{Testing}

\section{Analysis}

We included many features of object oriented languages, but we still lacked some
major features like static methods/fields, method overloading, implicit
constructors, <ADD MORE HERE>.

After adding object oriented features, we realized that our generated assembly
has a lot of room for improvement. Because our IR only minimally changed, all of
our previous optimizations still worked in place, but adding these new features
introduced a whole new class of generated assembly which could be much better
optimized. Optimizations like memory aliasing and address arithmetic are much
more relevant with this language extension than they were before.

\end{document}
