\documentclass{article}
% \usepackage{graphs}
\usepackage{fullpage}
\usepackage{array}
\usepackage{setspace}
\usepackage{proof}
\newcommand{\wild}{\mbox{\tt\char"5F}}

\newcommand{\nonterm}[1]{$\langle${#1}$\rangle$}
\newcommand{\tok}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\term}[1]{\textbf {#1}}
\newcommand{\OR}{\ensuremath{\ | \ \ }}

\newcommand{\proves}{\vdash}

\newcommand{\G}{\Gamma}
\newcommand{\cons}[2]{#1, \, #2}
\newcommand{\typed}[2]{#1 : #2}
\newcommand{\valid}[1]{#1 \; \mathit{valid}}
\newcommand{\typof}[3]{{#1} \proves \typed{#2}{#3}}

\title{Assignment 6\\ Object-oriented C0}
\author{15-411: Compiler Design\\
Alex Crichton (acrichto) and Robbie McElrath (rmcelrat)}

\begin{document}
\maketitle
\renewcommand{\baselinestretch}{1.5}

\section{Introduction}

We decided to add object-oriented features to to C0 for our lab 6. We strove to
maintain compatibility as much as possible with \emph{L4}, while supporting the
major features of OO programming that one would expect when working with a
language like C++ or Java.

Our compiler supports the basics of object oriented programming: classes,
single-class inheritance, method overriding, constructors, protected/private
access to fields/methods, and \texttt{super} invocation of parent methods.

\section{Specification}
The following are the changes/additions to the \emph{L5} specification. Any part
of the specification not addressed here is unchanged.

\subsection{Grammar}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{lcl}
  \nonterm{gdecl}      & ::= & $\cdots$ \OR \nonterm{cdecl} \OR \nonterm{mdef} \\
  \nonterm{cdecl}      & ::= & \term{class} \term{ident} \nonterm{ext-opt} \term{\{} \nonterm{citem-list} \term{\}} \term{;} \\
  \nonterm{ext-opt}    & ::= & $\epsilon$ \OR \term{extends} \term{ident} \\
  \nonterm{citem-list} & ::= & $\epsilon$ \OR \nonterm{citem} \nonterm{citem-list} \\
  \nonterm{citem}      & ::= & \nonterm{field} \OR \nonterm{fdecl} \OR \term{public:} \OR \term{private:} \\
  \nonterm{mdef}       & ::= & \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
                       & \OR & \nonterm{type} \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
  \nonterm{exp}        & ::= & $\cdots$ \OR \term{new} \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{super}  \nonterm{arg-list} \OR \term{super} \verb"->" \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{this} \verb"->" \term{ident} \OR \term{this} \verb"->" \term{ident} \nonterm{arg-list} \\
\end{tabular}

\subsection{Static Semantics}
\subsubsection{Classes}
\begin{itemize}
\item Classes follow the same lexical scoping rules as other gdecls (they are
      only available after their declaration).
\item Class declarations and definitions \emph{cannot} appear in external files.
\item Classes can be declared multiple times as long as the declarations are
      consistent, but their methods can be defined only once. Declared methods
      are not required to be defined.
\item Class names are types, and their names are in the type namespace.
\item Methods within classes form their own namespace, and can only be accessed
      via the object they belong to.
\item Functions that are not methods of a given class can only access the public
      fields and functions of that class.
\item Methods can access all fields and methods (both public and private) of any
      object that are the same type or a subtype of the class the method belongs to.
\item Subclasses do not get access to their parent's private fields or methods.
\item Fields within classes are in the same namespace as local variables within
      methods of that class (they can be referenced directly by name, but only
      by methods of the class they belong to).
\item Local variables are allowed to shadow class fields.
\item \term{super} may only be used within methods of a class $\alpha$ that
      extends some class $\beta$. \term{super} resolves to $\beta$ in this
      case. Subclasses can only access their direct parent via \term{super}.
\item Subclasses do not need to redeclare a method that they will override.
\item Subclasses cannot change the type of a function they are overriding.
\item A class must define a constructor.
\item Non-constructors cannot call their own constructor or their parent's.
      Constructors are the only method allowed to call the parent constructor.
\end{itemize}

\subsubsection{Typechecking}
We will define $\tau \subseteq \tau'$ to mean $\tau$ is a subtype of $\tau'$.
Any $\tau$ is a subtype of itself, and $\tau$ is a subtype of $\tau'$ if and only
if $\tau$ is a class that extends class $\tau'$, either directly or indirectly.
In other words, if you were to construct an inheritance tree, where each class
was a child node of the class it extended, then $\tau \subseteq \tau'$ would be
true iff $\tau = \tau'$ or if $\tau'$ was a direct ancestor of $\tau$ in the
tree. \\

Type equality checks were substitued with subtype checks throughout the
typechecker, so any variable of type \texttt{Foo} can be assigned any value that
is a subtype of \texttt{Foo} (including parameters). The only exception to this
rule are arrays of objects. A \texttt{Foo array} is not a subtype of a
\texttt{Bar array} even if \texttt{Foo} is a subtype of \texttt{Bar}. The only
other modification to the L5 typechecker is that methods have \texttt{this} and
the fields of their class bound as local variables at the beginning of the
function.

\subsection{Dynamic Semantics}
\begin{itemize}
\item After allocation, all class fields will be initialized to \texttt{0},
      \texttt{false}, or \texttt{null}. The required constructor will
      automatically be called after allocation of the object with \texttt{this}
      bound to the address of the object or \texttt{null} if it could not be
      allocated.
\item When invoking a method, the method will be resolved relative to the
      class the object was constructed as. For example, when invoking method
      \texttt{dostuff()} on an object of type \texttt{Bar} that extends
      \texttt{Foo}, \texttt{dostuff} will resolve to the implementation provided
      by \texttt{Bar}, \emph{not} that of \texttt{Foo} unless \texttt{Bar} does
      not override \texttt{Foo}'s implementation of \texttt{dostuff}. Note that
      this means method invocation cannot be determined statically - it depends
      on the type the object was constructed as (which may differ from the
      declared type due to subtyping).
\item The dynamic semantics are the same as they were in L5 in all other aspects.
\end{itemize}

\section{Implementation}

As explained in the dynamic semantics, we couldn't statically resolve all
function calls, so objects had to had an attribute called a vtable added to
them. The vtable is just a table of function pointers. The order of the
functions in the table for any one class doesn't matter, but all subclasses
of a particular class inherit the same table. For example, the following two
declarations result in the following two vtables:

\begin{center}
\begin{tabular}{|m{2.3in}|m{2in}|}
  \hline
    \begin{verbatim}
    class Foo {
      int a; int b;
      int fun1(); int fun2();
    }
    \end{verbatim}
    &
    \begin{verbatim}
    class Bar extends Foo {
      int c;
      int fun3();
    }
    int Bar::fun1() { ... }
    \end{verbatim}
  \\ \hline

    \begin{center}
      \begin{tabular}{cc}

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{vtable} \\ \hline
          \texttt{Foo::fun1} \\ \hline
          \texttt{Foo::fun2} \\ \hline
        \end{tabular}

        &

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{struct} \\ \hline
          \texttt{Foo::a} \\ \hline
          \texttt{Foo::b} \\ \hline
        \end{tabular}
      \end{tabular}
    \end{center}

    &

    \begin{center}
      \begin{tabular}{cc}

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{vtable} \\ \hline
          \texttt{Foo::fun1} \\ \hline
          \texttt{Bar::fun2} \\ \hline
          \texttt{Bar::fun3} \\ \hline
        \end{tabular}

        &

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{struct} \\ \hline
          \texttt{Foo::a} \\ \hline
          \texttt{Foo::b} \\ \hline
          \texttt{Bar::b} \\ \hline
        \end{tabular}
      \end{tabular}
    \end{center}

  \\ \hline
\end{tabular}
\end{center}

This way, when a \texttt{Bar} is casted to a \texttt{Foo}, the same instructions
can be used to call \texttt{Bar}'s \texttt{fun2} as opposed to \texttt{Foo}'s.
We had two options of where to put the vtables. They could either be part of
every object, or they could be located in the data section of the executable.
We decided that to reduce the overhead of each object, each object would have
a pointer to its vtable instead of the vtable being cloned all over the place.
This pointer is the first field in the struct (it's 8 bytes), and all other
instance variables come after the vtable.

Instance fields are laid out in a similar fashion as vtables are. A child class
inherits the same order of fields from its parent, and then adds its own fields
to the end of the struct created. This is for similar reasons that the vtable
has the same layout.

The next thing we have to do is make sure that when you're calling an object's
method, the object knows who it is. To accomplish this, we implicitly made
the first argument of every function on a class to be \texttt{this}. Whenever
a function call is made on an object, the object itself is passed along to the
function. References to fields or \texttt{this} then use this first argument
to perform address arithmetic, etc.

\section{Testing}

Our testing strategy for our compiler was fairly straightforward. Our first
consideration was to make sure that we didn't break any features of L4, so we
made sure our compiler passed all previous tests. The only exceptions to this
were those which used our new keywords like \texttt{this} or \texttt{new} as
variable names.

Otherwise, we made sure to write a fair number of tests which exercise different
functionality for each of the features in our language. We first collected a
large set of error test cases to make sure we rejected the programs. These
included most of the negative cases of the static semantics laid out from
above.

Afterwards, we started to write some code with our new extension to the
language. We quickly realized there were some features we really wanted, so we
decided to add them to the language (\texttt{super}, not declaring a function
override, etc.). After creating a \texttt{String} library, we were satisfied
with how the object orientation was working, and we started to write some tests
which leveraged the library.

\section{Analysis}

We included many features of object oriented languages, but we still lacked some
major features like static methods/fields, method overloading, and implicit
constructors to name a few.

After adding object oriented features, we realized that our generated assembly
has a lot of room for improvement. Because our IR only minimally changed, all of
our previous optimizations still worked in place, but adding these new features
introduced a whole new class of generated assembly which could be much better
optimized. Optimizations like memory aliasing and address arithmetic are much
more relevant with this language extension than they were before.

\end{document}
