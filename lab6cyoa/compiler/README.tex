\documentclass{article}
% \usepackage{graphs}
\usepackage{fullpage}
\usepackage{array}
\usepackage{setspace}
\usepackage{proof}
\newcommand{\wild}{\mbox{\tt\char"5F}}

\newcommand{\nonterm}[1]{$\langle${#1}$\rangle$}
\newcommand{\tok}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\term}[1]{\textbf {#1}}
\newcommand{\OR}{\ensuremath{\ | \ \ }}

\newcommand{\proves}{\vdash}

\newcommand{\G}{\Gamma}
\newcommand{\cons}[2]{#1, \, #2}
\newcommand{\typed}[2]{#1 : #2}
\newcommand{\valid}[1]{#1 \; \mathit{valid}}
\newcommand{\typof}[3]{{#1} \proves \typed{#2}{#3}}


\title{Assignment 6\\ Object-oriented C0}
\author{15-411: Compiler Design\\
Alex Crichton (acrichto) and Robbie McElrath (rmcelrat)}

\begin{document}
\maketitle
\renewcommand{\baselinestretch}{1.5}

\section{Introduction}

We decided to add object-oriented features to to C0 for our lab 6. We strove to
maintain compatibility as much as possible with \emph{L4}, while supporting the
major features of OO programming that one would expect when working with a
language like C++ or Java.

Our compiler supports the basics of object oriented programming: classes,
single-class inheritance, method overriding, constructors, protected/private
access to fields/methods, and \texttt{super} invocation of parent methods.

\section{Specification}
The following are the changes/additions to the \emph{L5} specification. Any part
of the specification not addressed here is unchanged.

\subsection{Grammar}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{lcl}
  \nonterm{gdecl}      & ::= & $\cdots$ \OR \nonterm{cdecl} \OR \nonterm{mdef} \\
  \nonterm{cdecl}      & ::= & \term{class} \term{ident} \nonterm{ext-opt} \term{\{} \nonterm{citem-list} \term{\}} \term{;} \\
  \nonterm{ext-opt}    & ::= & $\epsilon$ \OR \term{extends} \term{ident} \\
  \nonterm{citem-list} & ::= & $\epsilon$ \OR \nonterm{citem} \nonterm{citem-list} \\
  \nonterm{citem}      & ::= & \nonterm{field} \OR \nonterm{fdecl} \OR \term{public:} \OR \term{private:} \\
  \nonterm{mdef}       & ::= & \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
                       & \OR & \nonterm{type} \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
  \nonterm{exp}        & ::= & $\cdots$ \OR \term{new} \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{super}  \nonterm{arg-list} \OR \term{super} \verb"->" \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{this} \verb"->" \term{ident} \OR \term{this} \verb"->" \term{ident} \nonterm{arg-list} \\
\end{tabular}

\subsection{Static Semantics}
\subsubsection{Classes}
\begin{itemize}
\item Classes follow the same lexical scoping rules as other gdecls (they are
      only available after their declaration).
\item Class declarations and definitions \emph{cannot} appear in external files.
\item Classes can be declared multiple times as long as the declarations are
      consistent, but their methods can be defined only once. Declared methods
      are not required to be defined.
\item Class names are types, and their names are in the type namespace.
\item Methods within classes form their own namespace, and can only be accessed
      via the object they belong to.
\item Functions that are not methods of a given class can only access the public
      fields and functions of that class.
\item Methods can access all fields and methods (both public and private) of any
      object that are the same type or a subtype of the class the method belongs to.
\item Subclasses do not get access to their parent's private fields or methods.
\item Fields within classes are in the same namespace as local variables within
      methods of that class (they can be referenced directly by name, but only
      by methods of the class they belong to).
\item Local variables are allowed to shadow class fields.
\item \term{super} may only be used within methods of a class $\alpha$ that
      extends some class $\beta$. \term{super} resolves to $\beta$ in this
      case. Subclasses can only access their direct parent via \term{super}.
\item Subclasses do not need to redeclare a method that they will override.
\item Subclasses cannot change the type of a function they are overriding.
\item A class must define a constructor.
\item Non-constructors cannot call their own constructor or their parent's.
      Constructors are the only method allowed to call the parent constructor.
\end{itemize}

\subsubsection{Typechecking}
We will define $\tau \subseteq \tau'$ to mean $\tau$ is a subtype of $\tau'$.
Any $\tau$ is a subtype of itself, and $\tau$ is a subtype of $\tau'$ if and only
if $\tau$ is a class that extends class $\tau'$, either directly or indirectly.
In other words, if you were to construct an inheritance tree, where each class
was a child node of the class it extended, then $\tau \subseteq \tau'$ would be
true iff $\tau = \tau'$ or if $\tau'$ was a direct ancestor of $\tau$ in the
tree. \\

Type equality checks were substitued with subtype checks throughout the
typechecker, so any variable of type \texttt{Foo} can be assigned any value that
is a subtype of \texttt{Foo} (including parameters). The only exception to this
rule are arrays of objects. A \texttt{Foo array} is not a subtype of a
\texttt{Bar array} even if \texttt{Foo} is a subtype of \texttt{Bar}. The only
other modification to the L5 typechecker is that methods have \texttt{this} and
the fields of their class bound as local variables at the beginning of the
function.

\subsection{Dynamic Semantics}
\begin{itemize}
\item After allocation, all class fields will be initialized to \texttt{0},
      \texttt{false}, or \texttt{null}. The required constructor will
      automatically be called after allocation of the object with \texttt{this}
      bound to the address of the object or \texttt{null} if it could not be
      allocated.
\item When invoking a method, the method will be resolved relative to the
      class the object was constructed as. For example, when invoking method
      \texttt{dostuff()} on an object of type \texttt{Bar} that extends 
      \texttt{Foo}, \texttt{dostuff} will resolve to the implementation provided
      by \texttt{Bar}, \emph{not} that of \texttt{Foo} unless \texttt{Bar} does
      not override \texttt{Foo}'s implementation of \texttt{dostuff}. Note that
      this means method invocation cannot be determined statically - it depends
      on the type the object was constructed as (which may differ from the
      declared type due to subtyping).
\item The dynamic semantics are the same as they were in L5 in all other aspects.
\end{itemize}


\section{Implementation}

\section{Testing}

\section{Analysis}

We included many features of object oriented languages, but we still lacked some
major features like static methods/fields, method overloading, implicit
constructors, <ADD MORE HERE>.

After adding object oriented features, we realized that our generated assembly
has a lot of room for improvement. Because our IR only minimally changed, all of
our previous optimizations still worked in place, but adding these new features
introduced a whole new class of generated assembly which could be much better
optimized. Optimizations like memory aliasing and address arithmetic are much
more relevant with this language extension than they were before.

\end{document}
