\documentclass{article}
\usepackage{fullpage}
\usepackage{array}
\usepackage{setspace}
\usepackage{proof}
\newcommand{\wild}{\mbox{\tt\char"5F}}

\newcommand{\nonterm}[1]{$\langle${#1}$\rangle$}
\newcommand{\tok}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\term}[1]{\textbf {#1}}
\newcommand{\OR}{\ensuremath{\ | \ \ }}

\newcommand{\proves}{\vdash}

\newcommand{\G}{\Gamma}
\newcommand{\cons}[2]{#1, \, #2}
\newcommand{\typed}[2]{#1 : #2}
\newcommand{\valid}[1]{#1 \; \mathit{valid}}
\newcommand{\typof}[3]{{#1} \proves \typed{#2}{#3}}

\title{Assignment 6\\ Object-oriented C0}
\author{15-411: Compiler Design\\
Alex Crichton (acrichto) and Robbie McElrath (rmcelrat)}

\begin{document}
\maketitle
\renewcommand{\baselinestretch}{1.5}

\section{Introduction}

We decided to add object-oriented features to to C0 for our lab 6. We strove to
maintain compatibility as much as possible with \emph{L4}, while supporting the
major features of OO programming that one would expect when working with a
language like C++ or Java.

Our compiler supports the basics of object oriented programming: classes,
single-class inheritance, method overriding, constructors, protected/private
access to fields/methods, and \texttt{super} invocation of parent methods.

\section{Specification}
The following are the changes/additions to the \emph{L5} specification. Any part
of the specification not addressed here is unchanged.

\subsection{Grammar}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{lcl}
  \nonterm{gdecl}      & ::= & $\cdots$ \OR \nonterm{cdecl} \OR \nonterm{mdef} \\
  \nonterm{cdecl}      & ::= & \term{class} \term{ident} \nonterm{ext-opt} \term{\{} \nonterm{citem-list} \term{\}} \term{;} \\
  \nonterm{ext-opt}    & ::= & $\epsilon$ \OR \term{extends} \term{ident} \\
  \nonterm{citem-list} & ::= & $\epsilon$ \OR \nonterm{citem} \nonterm{citem-list} \\
  \nonterm{citem}      & ::= & \nonterm{field} \OR \nonterm{fdecl} \OR \term{public:} \OR \term{private:} \\
  \nonterm{mdef}       & ::= & \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
                       & \OR & \nonterm{type} \term{ident}::\term{ident} \nonterm{param-list} \nonterm{block} \\
  \nonterm{exp}        & ::= & $\cdots$ \OR \term{new} \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{super}  \nonterm{arg-list} \OR \term{super} \verb"->" \term{ident} \nonterm{arg-list} \\
                       & \OR & \term{this} \verb"->" \term{ident} \OR \term{this} \verb"->" \term{ident} \nonterm{arg-list} \\
\end{tabular}

\newpage
\subsection{Static Semantics}
\subsubsection{Classes}
\begin{itemize}
\item Classes follow the same lexical scoping rules as other gdecls (only
      available after their declaration).
\item Class declarations and definitions \emph{cannot} appear in external files.
\item Classes can be declared multiple times as long as the declarations are
      consistent, but their methods can be defined only once. Declared methods
      are not required to be defined.
\item Class names are types, and are thus in the type namespace.
\item Methods within classes form their own namespace, and can only be accessed
      via the object they belong to.
\item Functions that are not methods of a given class can only access the public
      fields and methods of that class.
\item Methods can access all fields and methods (both public and private) of any
      object that are the same type or a subtype of the class the method belongs to.
\item Subclasses do not get access to their parent's private fields or methods.
\item Fields within classes are in the same namespace as local variables within
      methods of that class (they can be referenced directly by name, but only
      by methods of the class they belong to).
\item Local variables are allowed to shadow class fields.
\item \term{super} may only be used within methods of a class $\alpha$ that
      extends some class $\beta$. \term{super} resolves to $\beta$ in this
      case. Subclasses can only access their direct parent via \term{super}.
\item Subclasses do not need to redeclare a method that they will override.
\item Subclasses cannot change the type of a function they are overriding.
\item A class must define a constructor.
\item Non-constructors cannot call their own constructor or their parent's.
      Constructors are the only method allowed to call the parent constructor.
\end{itemize}

\subsubsection{Typechecking}
We will define $\tau \subseteq \tau'$ to mean $\tau$ is a subtype of $\tau'$.
Any $\tau$ is a subtype of itself, and $\tau$ is a subtype of $\tau'$ if and only
if $\tau$ is a class that extends class $\tau'$, either directly or indirectly.
In other words, if you were to construct an inheritance tree, where each class
was a child node of the class it extended, then $\tau \subseteq \tau'$ would be
true iff $\tau = \tau'$ or if $\tau'$ was a direct ancestor of $\tau$ in the
tree. \\

Type equality checks were substitued with subtype checks throughout the
typechecker, so any variable (including parameters) of type $\alpha$ can carry
a value that is a subtype of $\alpha$. The only exception to this
rule are arrays of objects. An \texttt{$\alpha$ array} is not a subtype of a
\texttt{$\beta$ array} even if \texttt{$\alpha$} is a subtype of
\texttt{$\beta$}. The only other modification to the L5 typechecker is that
methods have \texttt{this} and the fields of their class bound as local
variables at the beginning of the function.

\subsection{Dynamic Semantics}
\begin{itemize}
\item After object allocation, all class fields will be initialized to \texttt{0},
      \texttt{false}, or \texttt{null}. The required constructor will
      automatically be called after allocation of the object with \texttt{this}
      bound to the address of the object or \texttt{null} if it could not be
      allocated.
\item When invoking a method on an object, the method will be resolved by
      walking up the inheritance tree starting at the class the object was
      constructed as. For example, when invoking
      method \texttt{dostuff()} on an object of type \texttt{Bar} that extends
      \texttt{Foo}, \texttt{dostuff} will resolve to the implementation provided
      by \texttt{Bar}, \emph{not} that of \texttt{Foo} unless \texttt{Bar} does
      not override \texttt{Foo}'s implementation of \texttt{dostuff}. Note that
      this means method invocation cannot be determined statically - it depends
      on the type the object was constructed as (which may differ from the
      declared type due to subtyping).
\item With respect to memory safety, initial allocations of objects raises
      \texttt{SIGSEGV} if the allocation fails. Whenever a method is invoked
      on an object, \texttt{SIGSEGV} is raised when the object is NULL.
      Otherwise, all field accesses in a method do not need to be checked
      because it is guaranteed that \texttt{this} is a valid pointer.
\item The dynamic semantics are the same as they were in L5 in all other
      aspects.
\end{itemize}

\section{Implementation}

\subsection{Front End}

For the front-end grammar, one of the major problems was that once a class was
defined, an \texttt{IDENT} could be considered a type. This runs into the same
problem as with \texttt{typedef}s, so we employed a similar solution. As soon
as the declaration ``\texttt{class Foo}'' is seen, \texttt{Foo} is immediately
added as a type to our tables, so further tokens named \texttt{Foo} will return
a \texttt{TYPE} token instead of an \texttt{IDENT} token.

A huge benefit of using this type of parsing, was that it was impossible to
call \texttt{new} with a class name that isn't a class, because it's
grammatically invalid. This can cause some odd error messages, but the first
line of the error is normally fairly indicative of what the error is.
Furthermore, elaboration was much simpler, only having to check for validity
of method names as opposed to methods and classes.

Other static analyses, initialization checking, return checking, and checking
for main, all remained virtually untouched. The analysis which changed the most
was typechecking. It turned out that typechecking and translation into the IR
were the two largest changes we had to make, but both changes were very similar.
In addition to the previous environment information, we had to have information
about classes. This class information included public/private access, methods,
fields, and the parent class.

\subsection{Back End}

One of the major goals of our implementation was to modify our IR as little as
possible. We knew we were going to have to change the front-end of our compiler
drastically, but we were hoping to reduce all of the object-oriented semantics
to the same IR we had for L4. We largely succeeded in this goal, but we had to
add the ability to indirectly call a function instead of just by label.
Otherwise, nothing in our IR changed, so we were able to retain the benefit of
all our previous optimizations with little effort. In the end, our
optimizations directory had only 19 insertions and 16 deletions.

Each method needs to know which object it was called on, so we insert a
parameter in every method that will store a pointer to ``\texttt{this}''.
All object field accesses are elaborated from \texttt{\emph{name}} to
\texttt{this->\emph{name}}. \texttt{this} is implemented as a struct containing
a pointer to a vtable (discussed later), followed by all the fields within the
class. Because we convert \texttt{this} to a struct pointer and store the
object's fields in the struct, we did not need to modify the IR or code
generation to support this aspect of objects.

As explained in the dynamic semantics, we can't statically resolve method
invocations because of subtyping, so we add a virtual function table, or vtable
to the struct representing an object. The vtable is an array of function
pointers, and each method is assigned a fixed location in the table. When a
class is extended, the parent class's vtable is copied and new methods are
added to the end of the table. This allows method invocation to work properly
even on subclasses because the indices of the function pointers don't change
when extending a class. If the subclass overrides a method, the corresponding
entry in the new vtable is updated to point to the new implementation. As an
example, the following two class declarations result in the following vtables:

\begin{center}
%\renewcommand{\arraystretch}{1.0}
\begin{tabular}{m{2.3in}|m{2in}}
    \begin{verbatim}
    class Foo {
      int a; int b;
      int fun1(); int fun2();
    }
    \end{verbatim}
    &
    \begin{verbatim}
    class Bar extends Foo {
      int c;
      int fun3();
    }
    int Bar::fun1() { ... }\end{verbatim}
  \\

    \begin{center}
      \begin{tabular}{cc}

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{vtable\_Foo} \\ \hline
          \texttt{Foo::fun1} \\ \hline
          \texttt{Foo::fun2} \\ \hline
        \end{tabular}

        &

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{struct} \\ \hline
          \texttt{\&vtable\_Foo} \\ \hline
          \texttt{Foo::a} \\ \hline
          \texttt{Foo::b} \\ \hline
        \end{tabular}
      \end{tabular}
    \end{center}

    &

    \begin{center}
      \begin{tabular}{cc}

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{vtable\_Bar} \\ \hline
          \texttt{Bar::fun1} \\ \hline
          \texttt{Foo::fun2} \\ \hline
          \texttt{Bar::fun3} \\ \hline
        \end{tabular}

        &

        \begin{tabular}{|c|c|}
          \multicolumn{1}{c}{struct} \\ \hline
          \texttt{\&vtable\_Bar} \\ \hline
          \texttt{Foo::a} \\ \hline
          \texttt{Foo::b} \\ \hline
          \texttt{Bar::c} \\ \hline
        \end{tabular}
      \end{tabular}
    \end{center}

\end{tabular}
\end{center}

When a \texttt{Bar} is cast to a \texttt{Foo}, the same instructions can be used
to call \texttt{Bar}'s \texttt{fun2} as opposed to \texttt{Foo}'s.  We had two
options of where to put the vtables. They could either be included in every
object, or they could be located in the data section of the executable.  Placing
a vtable copy in every object would eliminate one memory access per method
invocation, but it could dramatically increase the size of objects.  We decided
to just have a single copy of each vtable, and have each object store a pointer
to its corresponding vtable.  This pointer is the first field in the struct
(it's 8 bytes), and all other instance variables come after the vtable. The
vtables themselves are output in the assembly in the \texttt{.data} section.

Instance fields are laid out in an object's struct in a similar fashion to
vtables. A child class inherits the same order of fields from its parent, and
then adds its own fields to the end of the new struct. Structs use this layout
for the same reasons vtables do.

\section{Testing}

The testing strategy for our compiler was fairly straightforward. Our first
consideration was to make sure that we didn't break any features of L4, so we
made sure our compiler passed all previous tests. The only exceptions to this
were those which used our new keywords like \texttt{this} or \texttt{new} as
variable names. Because we weren't changing L4 in any fundamental ways, we were
able to use the same driver as before along with the same syntax for tests.

We wrote a fair number of tests which exercise different
functionality for each of the features in our language. We first collected a
large set of error test cases to make sure we reject invalid programs. These
include all of the negative cases of the static semantics laid out from above.

Afterwards, we started to write some code with our new extension to the
language. We quickly realized there were some features we really wanted, so we
decided to add them to the language (\texttt{super}, not declaring a function
override, etc.). After creating a \texttt{String} library, we were satisfied
with how the object orientation was working, and we started to write some tests
which leveraged the library.

Our end result was 33 tests, 24 of which were error tests. This is not close to
an exhaustive test suite, and crowd-sourced tests would most likely expose some
pitfalls of our implementation. After writing these tests and exhibiting as much
functionality of the object oriented features that we could, we decided that
we had enough.

\section{Analysis}

We included many features of object oriented languages, but we still lacked some
major features like interfaces, abstract classes, static methods/fields, method
overloading, and implicit constructors to name a few. Some of these wouldn't
really add much benefit (static methods/fields and possibly interfaces), while
the others are much desirable. Most of these would not require much change at
the IR level, but mostly front-end static analysis changes.

After adding object oriented features, we realized that our generated assembly
has a lot of room for improvement. Because our IR only minimally changed, all of
our previous optimizations still worked in place, but adding these new features
introduced a whole new class of generated assembly which could be much better
optimized. Optimizations like memory aliasing and address arithmetic are much
more relevant with this language extension than they were before.

Furthermore, garbage collection didn't seem particularly useful in L5 because
a program didn't look very nice if there were a bunch of allocations all over
the place, so this probably wouldn't happen too often. With OO features, it's
much more natural to create objects with \texttt{new}, so many more objects
would probably be created. After implementing just a \texttt{String} class, we
realized that we were calling \texttt{malloc} left and right all over the place.
These leaks can certainly become a serious issue, especially in a long running
program.

\end{document}
